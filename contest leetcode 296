class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        temp={}
        for i in range(len(nums)):
            temp[num[i]]=i
        
        for i in range(len(op)):
            if op[i][0] not in temp:
                temp[op[i][0]]=temp[op[i][1]]
            nums[temp[op[i][0]]]=op[i][1]
            temp[op[i][0]]=temp[op[i][1]]
            return nums
            
                
        
        class Solution {
public:
    vector<int> arrayChange(vector<int>& A, vector<vector<int>>& op) {
    unordered_map<int,int> store;
        
    for(int i=0;i<A.size();i++) store[A[i]]=i;
        
    for(auto i:op){
        A[store[i[0]]]= i[1];           //replace value to its index
        store[i[1]]= store[i[0]];       //update new value with its index
    }
    return A;
}
};


class Solution {
public:
    int minMaxGame(vector<int>& nums) {
       for(int n=size(a);n>1;n-=(n/2))
       {
           for(int i=0;i<n/2;i++)
               nums[i]=(i%2)?max(nums[2*i],nums[2*i+1]):min(nums[2*i],nums[2*i+1]);
       }
        return nums[0];
    }
};
class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        l=nums
        while(l)>1:
            ismin=True
            temp=[]
            for i in range(0,len(l),2):
                if ismin:
                    temp.append(min(l[i:i+2]))
                else:
                    temp.append(max(l[i:i+2]))
                ismin=not ismin
            l=temp
            return l[0]
                    
        
